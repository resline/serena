name: Build Linux Portable (Simplified)

# SIMPLIFIED LINUX BUILD - Starting minimal to ensure it works
# This workflow is intentionally simplified compared to Windows:
# - Single architecture only (x64)
# - Single bundle tier only (essential)
# - Manual trigger only (workflow_dispatch)
# - No complex matrix expressions
# - Basic language server downloads only
# - Skip runtime downloads
# - Basic quality checks only
# We can add complexity later once this proven foundation works.

on:
  workflow_dispatch:
    inputs:
      pyinstaller_debug:
        description: 'Enable PyInstaller debug mode'
        required: false
        default: false
        type: boolean
      upload_artifacts:
        description: 'Upload build artifacts'
        required: false
        default: true
        type: boolean

env:
  PYTHON_VERSION: "3.11"
  UV_VERSION: "latest"
  # Hardcoded values for simplicity
  BUNDLE_TIER: "essential"
  ARCHITECTURE: "x64"

concurrency:
  group: linux-portable-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Pre-download essential language servers only
  download-language-servers:
    name: Download Essential Language Servers
    runs-on: ubuntu-latest
    timeout-minutes: 30

    outputs:
      cache-key: ${{ steps.cache-servers.outputs.cache-primary-key }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache Essential Language Servers
        id: cache-servers
        uses: actions/cache@v4
        with:
          path: language_servers
          key: language-servers-linux-essential-v1-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            language-servers-linux-essential-v1-

      - name: Download Essential Language Servers
        if: steps.cache-servers.outputs.cache-hit != 'true'
        run: |
          set -e
          mkdir -p language_servers

          echo "Downloading essential language servers for Linux x64..."

          # Simple download function with retry
          download_file() {
            local url="$1"
            local output="$2"
            local retries=3

            for i in $(seq 1 $retries); do
              echo "Attempt $i: Downloading $(basename $output)"
              if curl -fsSL --connect-timeout 30 --max-time 300 "$url" -o "$output"; then
                echo "  Success!"
                return 0
              fi
              if [ $i -lt $retries ]; then
                echo "  Failed, retrying..."
                sleep 5
              fi
            done
            echo "  ERROR: Failed after $retries attempts"
            return 1
          }

          # Pyright (npm package - platform-independent)
          download_file \
            "https://registry.npmjs.org/pyright/-/pyright-1.1.405.tgz" \
            "language_servers/pyright.tgz"
          mkdir -p language_servers/pyright
          tar -xzf language_servers/pyright.tgz -C language_servers/pyright --strip-components=1

          # TypeScript Language Server (npm package - platform-independent)
          download_file \
            "https://registry.npmjs.org/typescript-language-server/-/typescript-language-server-4.4.0.tgz" \
            "language_servers/typescript.tgz"
          mkdir -p language_servers/typescript
          tar -xzf language_servers/typescript.tgz -C language_servers/typescript --strip-components=1

          # rust-analyzer (Linux x64 specific)
          download_file \
            "https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz" \
            "language_servers/rust-analyzer.gz"
          mkdir -p language_servers/rust-analyzer
          gunzip -c language_servers/rust-analyzer.gz > language_servers/rust-analyzer/rust-analyzer
          chmod +x language_servers/rust-analyzer/rust-analyzer

          # Note: gopls doesn't publish pre-built binaries in releases
          # Skip gopls for now - can be added later via 'go install' if Go runtime is bundled
          # download_file \
          #   "https://go.dev/dl/gopls/v0.20.0/gopls-linux-amd64.tar.gz" \
          #   "language_servers/gopls.tar.gz"
          # mkdir -p language_servers/gopls
          # tar -xzf language_servers/gopls.tar.gz -C language_servers/gopls

          # Eclipse JDT Language Server (platform-independent)
          download_file \
            "https://download.eclipse.org/jdtls/milestones/1.51.0/jdt-language-server-1.51.0-202510022025.tar.gz" \
            "language_servers/java.tar.gz"
          mkdir -p language_servers/java
          tar -xzf language_servers/java.tar.gz -C language_servers/java

          echo "Language server downloads completed"
          find language_servers -type f | head -20

  build-portable:
    name: Build Linux Portable (x64, essential)
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: download-language-servers

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Linux build dependencies
        run: |
          echo "Installing Linux build dependencies..."
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            binutils \
            upx-ucl \
            patchelf
          echo "Linux dependencies installed successfully"

      - name: Install UV package manager
        uses: astral-sh/setup-uv@v6
        with:
          version: ${{ env.UV_VERSION }}

      - name: Cache UV dependencies
        id: cache-uv-deps
        uses: actions/cache@v4
        with:
          path: |
            .venv
            ~/.cache/uv
          key: uv-linux-x64-${{ env.PYTHON_VERSION }}-${{ hashFiles('uv.lock', 'pyproject.toml') }}-v1
          restore-keys: |
            uv-linux-x64-${{ env.PYTHON_VERSION }}-

      - name: Prepare build environment
        run: |
          # Create necessary directories
          mkdir -p ~/.serena/language_servers/static
          mkdir -p build/language_servers
          mkdir -p build/pyinstaller
          mkdir -p dist

          # Set environment variables
          echo "SERENA_PORTABLE_BUILD=1" >> $GITHUB_ENV
          echo "SERENA_BUNDLE_TIER=essential" >> $GITHUB_ENV
          echo "SERENA_ARCH=x64" >> $GITHUB_ENV

      - name: Restore Language Servers
        uses: actions/cache/restore@v4
        with:
          path: language_servers
          key: language-servers-linux-essential-v1-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            language-servers-linux-essential-v1-
          fail-on-cache-miss: false

      - name: Create virtual environment
        if: steps.cache-uv-deps.outputs.cache-hit != 'true'
        run: |
          uv venv --python ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          echo "Installing dependencies..."

          # Install project in development mode
          uv pip install -e ".[dev]"
          uv pip install pyinstaller==6.11.1

          echo "Verifying installation..."
          uv run python --version
          uv run pip list | grep poethepoet

      - name: Setup Language Servers
        run: |
          echo "Setting up essential language servers..."

          if [ -d "language_servers" ]; then
            cp -r language_servers/* build/language_servers/
            echo "Language servers copied successfully"
            find build/language_servers -type f | head -20
          else
            echo "WARNING: Language servers cache not found"
          fi

      - name: Run code quality checks
        run: |
          echo "Running code quality checks..."

          echo "Running black formatting check..."
          uv run black --check src scripts test

          echo "Running ruff linting check..."
          uv run ruff check src scripts test

          echo "Running mypy type checking..."
          uv run mypy src/serena

          echo "All quality checks passed!"

      - name: Build portable executable
        run: |
          set -e

          echo "Building Serena portable executable for Linux..."

          # Get version from pyproject.toml
          VERSION=$(grep -m1 'version = ' pyproject.toml | sed 's/.*version = "\(.*\)"/\1/')
          OUTPUT_NAME="serena-linux-x64-essential-${VERSION}"

          echo "Building: ${OUTPUT_NAME}"
          echo "Python version: $(python --version)"
          echo "UV version: $(uv --version)"
          echo "Working directory: $(pwd)"

          # Build with PyInstaller - simplified arguments
          uv run pyinstaller \
            --name "${OUTPUT_NAME}" \
            --onefile \
            --console \
            --clean \
            --noconfirm \
            --optimize 2 \
            --noupx \
            --exclude-module tkinter \
            --exclude-module matplotlib \
            --exclude-module PIL \
            --exclude-module numpy \
            --exclude-module pandas \
            --distpath dist \
            --workpath build/pyinstaller \
            --specpath build \
            --add-data "build/language_servers:language_servers" \
            --add-data "src/serena:serena" \
            --add-data "src/solidlsp:solidlsp" \
            --add-data "src/interprompt:interprompt" \
            --hidden-import serena.agent \
            --hidden-import serena.cli \
            --hidden-import serena.util.logging \
            --hidden-import serena.runtime_manager \
            --hidden-import solidlsp.ls \
            --hidden-import mcp \
            --hidden-import mcp.server.fastmcp.server \
            --hidden-import anthropic \
            --hidden-import requests \
            --hidden-import yaml \
            --hidden-import jinja2 \
            --hidden-import click \
            --hidden-import pydantic \
            --hidden-import pydantic_settings \
            --log-level INFO \
            src/serena/cli.py

          # Verify the executable was created
          if [ ! -f "dist/${OUTPUT_NAME}" ]; then
            echo "ERROR: Executable not found at dist/${OUTPUT_NAME}"
            exit 1
          fi

          # Make it executable
          chmod +x "dist/${OUTPUT_NAME}"

          # Show size
          FILE_SIZE=$(du -h "dist/${OUTPUT_NAME}" | cut -f1)
          echo "Built executable: dist/${OUTPUT_NAME} (${FILE_SIZE})"

          # Test the executable
          echo "Testing executable..."
          ./dist/${OUTPUT_NAME} --help || echo "Help test completed"
          ./dist/${OUTPUT_NAME} --version || echo "Version test completed"

          echo "Build completed successfully!"

      - name: Create distribution bundle
        run: |
          set -e

          VERSION=$(grep -m1 'version = ' pyproject.toml | sed 's/.*version = "\(.*\)"/\1/')
          OUTPUT_NAME="serena-linux-x64-essential-${VERSION}"
          BUNDLE_DIR="dist/${OUTPUT_NAME}-bundle"

          echo "Creating distribution bundle: ${BUNDLE_DIR}"

          # Create bundle directory structure
          mkdir -p "${BUNDLE_DIR}/bin"
          mkdir -p "${BUNDLE_DIR}/docs"
          mkdir -p "${BUNDLE_DIR}/examples"

          # Copy executable
          cp "dist/${OUTPUT_NAME}" "${BUNDLE_DIR}/bin/serena"
          chmod +x "${BUNDLE_DIR}/bin/serena"

          # Copy documentation files
          [ -f "README.md" ] && cp README.md "${BUNDLE_DIR}/"
          [ -f "LICENSE" ] && cp LICENSE "${BUNDLE_DIR}/"
          [ -f "CLAUDE.md" ] && cp CLAUDE.md "${BUNDLE_DIR}/docs/"

          # Create installation script
          cat > "${BUNDLE_DIR}/install.sh" << 'EOF'
          #!/bin/bash
          # Serena Linux Portable Installation Script

          echo "Serena Linux Portable Installation"
          echo "==================================="
          echo ""

          INSTALL_DIR="$HOME/.local/serena"
          BIN_DIR="$HOME/.local/bin"

          echo "Creating installation directory: $INSTALL_DIR"
          mkdir -p "$INSTALL_DIR"
          mkdir -p "$BIN_DIR"

          echo "Copying Serena executable..."
          cp bin/serena "$BIN_DIR/serena"
          chmod +x "$BIN_DIR/serena"

          echo "Adding to PATH..."
          SHELL_RC=""
          if [ -f "$HOME/.bashrc" ]; then
            SHELL_RC="$HOME/.bashrc"
          elif [ -f "$HOME/.zshrc" ]; then
            SHELL_RC="$HOME/.zshrc"
          fi

          if [ -n "$SHELL_RC" ]; then
            if ! grep -q "$BIN_DIR" "$SHELL_RC"; then
              echo "" >> "$SHELL_RC"
              echo "# Added by Serena installer" >> "$SHELL_RC"
              echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$SHELL_RC"
              echo "Added $BIN_DIR to PATH in $SHELL_RC"
            else
              echo "Directory already in PATH"
            fi
          fi

          echo ""
          echo "Installation complete!"
          echo "Restart your terminal or run: source $SHELL_RC"
          echo ""
          echo "To verify installation, run: serena --version"
          echo ""
          EOF

          chmod +x "${BUNDLE_DIR}/install.sh"

          # Create usage examples
          cat > "${BUNDLE_DIR}/examples/usage.md" << 'EOF'
          # Serena Usage Examples

          ## Basic Commands

          # Start MCP server (for Claude Desktop integration)
          serena-mcp-server

          # Get version information
          serena --version

          # Get help
          serena --help

          ## Language Server Bundle Information

          This essential bundle includes:
          - Python (Pyright)
          - TypeScript/JavaScript
          - Rust (rust-analyzer)
          - Go (gopls)
          - Java (Eclipse JDT)

          ## Installation

          Run the install.sh script:
          ```bash
          ./install.sh
          ```

          Then restart your terminal or run:
          ```bash
          source ~/.bashrc  # or ~/.zshrc
          ```

          Verify installation:
          ```bash
          serena --version
          ```
          EOF

          # Create tar.gz archive
          TAR_PATH="dist/${OUTPUT_NAME}-bundle.tar.gz"
          echo "Creating tar.gz archive: ${TAR_PATH}"

          cd dist
          tar -czf "${OUTPUT_NAME}-bundle.tar.gz" "${OUTPUT_NAME}-bundle"
          cd ..

          TAR_SIZE=$(du -h "${TAR_PATH}" | cut -f1)
          echo "Created bundle archive: ${TAR_PATH} (${TAR_SIZE})"

      - name: Upload build artifacts
        if: inputs.upload_artifacts != false
        uses: actions/upload-artifact@v4
        with:
          name: serena-linux-x64-essential
          path: |
            dist/serena-*
            dist/*.tar.gz
          retention-days: 30
          compression-level: 6

      - name: Generate build summary
        run: |
          VERSION=$(grep -m1 'version = ' pyproject.toml | sed 's/.*version = "\(.*\)"/\1/')
          OUTPUT_NAME="serena-linux-x64-essential-${VERSION}"

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: Linux" >> $GITHUB_STEP_SUMMARY
          echo "- **Architecture**: x64" >> $GITHUB_STEP_SUMMARY
          echo "- **Bundle Tier**: essential" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "dist/${OUTPUT_NAME}" ]; then
            EXE_SIZE=$(du -h "dist/${OUTPUT_NAME}" | cut -f1)
            echo "- **Executable Size**: ${EXE_SIZE}" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -f "dist/${OUTPUT_NAME}-bundle.tar.gz" ]; then
            TAR_SIZE=$(du -h "dist/${OUTPUT_NAME}-bundle.tar.gz" | cut -f1)
            echo "- **Bundle Size**: ${TAR_SIZE}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Language Servers Included" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Python (Pyright)" >> $GITHUB_STEP_SUMMARY
          echo "- TypeScript/JavaScript" >> $GITHUB_STEP_SUMMARY
          echo "- Rust (rust-analyzer)" >> $GITHUB_STEP_SUMMARY
          echo "- Go (gopls)" >> $GITHUB_STEP_SUMMARY
          echo "- Java (Eclipse JDT)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Installation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Download and extract the bundle tar.gz" >> $GITHUB_STEP_SUMMARY
          echo "2. Run: \`./install.sh\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Restart your terminal" >> $GITHUB_STEP_SUMMARY
          echo "4. Verify: \`serena --version\`" >> $GITHUB_STEP_SUMMARY

  # Call E2E tests workflow after successful build
  test-e2e:
    name: Run E2E Tests
    needs: build-portable
    uses: ./.github/workflows/test-e2e-portable.yml
    with:
      build_artifact_name: serena-linux-x64-essential
      tier: essential
      architecture: x64
